<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-08-30T20:06:06Z</updated>

    
    <entry>
        <title>Announcing Rust 1.37.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html" type="text/html" title="Announcing Rust 1.37.0" />
        <published>2019-08-15T00:00:00Z</published>
        <updated>2019-08-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.37.0. Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.37.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15&quot;&gt;detailed release notes for 1.37.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.37.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.37.0-stable&quot;&gt;&lt;/a&gt;What's in 1.37.0 stable&lt;/h2&gt;
&lt;p&gt;The highlights of Rust 1.37.0 include referring to &lt;code&gt;enum&lt;/code&gt; variants through &lt;code&gt;type&lt;/code&gt; aliases, built-in &lt;code&gt;cargo vendor&lt;/code&gt;, unnamed &lt;code&gt;const&lt;/code&gt; items, profile-guided optimization, a &lt;code&gt;default-run&lt;/code&gt; key in Cargo, and &lt;code&gt;#[repr(align(N))]&lt;/code&gt; on &lt;code&gt;enum&lt;/code&gt;s. Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#referring-to-enum-variants-through-type-aliases&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;referring-to-enum-variants-through-type-aliases&quot;&gt;&lt;/a&gt;Referring to &lt;code&gt;enum&lt;/code&gt; variants through &lt;code&gt;type&lt;/code&gt; aliases&lt;/h3&gt;
&lt;p&gt;With Rust 1.37.0, you can now refer to &lt;code&gt;enum&lt;/code&gt; variants through type aliases. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;type ByteOption = Option&amp;lt;u8&amp;gt;;

fn increment_or_zero(x: ByteOption) -&amp;gt; u8 {
    match x {
        ByteOption::Some(y) =&amp;gt; y + 1,
        ByteOption::None =&amp;gt; 0,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In implementations, &lt;code&gt;Self&lt;/code&gt; acts like a type alias. So in Rust 1.37.0, you can also refer to &lt;code&gt;enum&lt;/code&gt; variants with &lt;code&gt;Self::Variant&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl Coin {
    fn value_in_cents(&amp;amp;self) -&amp;gt; u8 {
        match self {
            Self::Penny =&amp;gt; 1,
            Self::Nickel =&amp;gt; 5,
            Self::Dime =&amp;gt; 10,
            Self::Quarter =&amp;gt; 25,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To be more exact, Rust now allows you to refer to &lt;code&gt;enum&lt;/code&gt; variants through &lt;em&gt;&amp;quot;type-relative resolution&amp;quot;&lt;/em&gt;, &lt;code&gt;&amp;lt;MyType&amp;lt;..&amp;gt;&amp;gt;::Variant&lt;/code&gt;. More details are available in &lt;a href=&quot;https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847&quot;&gt;the stabilization report&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#built-in-cargo-support-for-vendored-dependencies&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;built-in-cargo-support-for-vendored-dependencies&quot;&gt;&lt;/a&gt;Built-in Cargo support for vendored dependencies&lt;/h3&gt;
&lt;p&gt;After being available &lt;a href=&quot;https://crates.io/crates/cargo-vendor&quot;&gt;as a separate crate&lt;/a&gt; for years, the &lt;code&gt;cargo vendor&lt;/code&gt; command is now integrated directly into Cargo. The command fetches all your project's dependencies unpacking them into the &lt;code&gt;vendor/&lt;/code&gt; directory, and shows the configuration snippet required to use the vendored code during builds.&lt;/p&gt;
&lt;p&gt;There are multiple cases where &lt;code&gt;cargo vendor&lt;/code&gt; is already used in production: the Rust compiler &lt;code&gt;rustc&lt;/code&gt; uses it to ship all its dependencies in release tarballs, and projects with monorepos use it to commit the dependencies' code in source control.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#using-unnamed-const-items-for-macros&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;using-unnamed-const-items-for-macros&quot;&gt;&lt;/a&gt;Using unnamed &lt;code&gt;const&lt;/code&gt; items for macros&lt;/h3&gt;
&lt;p&gt;You can now create &lt;a href=&quot;https://github.com/rust-lang/rust/pull/61347/&quot;&gt;unnamed &lt;code&gt;const&lt;/code&gt; items&lt;/a&gt;. Instead of giving your constant an explicit name, simply name it &lt;code&gt;_&lt;/code&gt; instead. For example, in the &lt;code&gt;rustc&lt;/code&gt; compiler we find:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// Type size assertion where the first parameter
/// is a type and the second is the expected size.
#[macro_export]
macro_rules! static_assert_size {
    ($ty:ty, $size:expr) =&amp;gt; {
        const _: [(); $size] = [(); ::std::mem::size_of::&amp;lt;$ty&amp;gt;()];
        //    ^ Note the underscore here.
    }
}

static_assert_size!(Option&amp;lt;Box&amp;lt;String&amp;gt;&amp;gt;, 8); // 1.
static_assert_size!(usize, 8); // 2.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the second &lt;code&gt;static_assert_size!(..)&lt;/code&gt;: thanks to the use of unnamed constants, you can define new items without naming conflicts. Previously you would have needed to write &lt;code&gt;static_assert_size!(MY_DUMMY_IDENTIFIER, usize, 8);&lt;/code&gt;. Instead, with Rust 1.37.0, it now becomes easier to create ergonomic and reusable declarative and procedural macros for static analysis purposes.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#profile-guided-optimization&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;profile-guided-optimization&quot;&gt;&lt;/a&gt;Profile-guided optimization&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;rustc&lt;/code&gt; compiler now comes with &lt;a href=&quot;https://github.com/rust-lang/rust/pull/61268/&quot;&gt;support for Profile-Guided Optimization (PGO)&lt;/a&gt; via the &lt;code&gt;-C profile-generate&lt;/code&gt; and &lt;code&gt;-C profile-use&lt;/code&gt; flags.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Profile-guided_optimization&quot;&gt;Profile-Guided Optimization&lt;/a&gt; allows the compiler to optimize code based on feedback from real workloads. It works by compiling the program to optimize in two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First, the program is built with instrumentation inserted by the compiler. This is done by passing the &lt;code&gt;-C profile-generate&lt;/code&gt; flag to &lt;code&gt;rustc&lt;/code&gt;. The instrumented program then needs to be run on sample data and will write the profiling data to a file.&lt;/li&gt;
&lt;li&gt;Then, the program is built &lt;em&gt;again&lt;/em&gt;, this time feeding the collected profiling data back into &lt;code&gt;rustc&lt;/code&gt; by using the &lt;code&gt;-C profile-use&lt;/code&gt; flag. This build will make use of the collected data to allow the compiler to make better decisions about code placement, inlining, and other optimizations.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For more in-depth information on Profile-Guided Optimization, please refer to the corresponding &lt;a href=&quot;https://doc.rust-lang.org/rustc/profile-guided-optimization.html&quot;&gt;chapter in the rustc book&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#choosing-a-default-binary-in-cargo-projects&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;choosing-a-default-binary-in-cargo-projects&quot;&gt;&lt;/a&gt;Choosing a default binary in Cargo projects&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-run.html&quot;&gt;&lt;code&gt;cargo run&lt;/code&gt;&lt;/a&gt; is great for quickly testing CLI applications. When multiple binaries are present in the same package, you have to explicitly declare the name of the binary you want to run with the &lt;code&gt;--bin&lt;/code&gt; flag. This makes &lt;code&gt;cargo run&lt;/code&gt; not as ergonomic as we'd like, especially when a binary is called more often than the others.&lt;/p&gt;
&lt;p&gt;Rust 1.37.0 addresses the issue by adding &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/manifest.html#the-default-run-field&quot;&gt;&lt;code&gt;default-run&lt;/code&gt;&lt;/a&gt;, a new key in &lt;code&gt;Cargo.toml&lt;/code&gt;. When the key is declared in the &lt;code&gt;[package]&lt;/code&gt; section, &lt;code&gt;cargo run&lt;/code&gt; will default to the chosen binary if the &lt;code&gt;--bin&lt;/code&gt; flag is not passed.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#[repr(align(n))]-on-enums&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;[repr(align(n))]-on-enums&quot;&gt;&lt;/a&gt;&lt;code&gt;#[repr(align(N))]&lt;/code&gt; on &lt;code&gt;enum&lt;/code&gt;s&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers&quot;&gt;The &lt;code&gt;#[repr(align(N))]&lt;/code&gt; attribute&lt;/a&gt; can be used to raise the &lt;a href=&quot;https://doc.rust-lang.org/reference/type-layout.html#size-and-alignment&quot;&gt;alignment&lt;/a&gt; of a type definition. Previously, the attribute was only allowed on &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. With Rust 1.37.0, the attribute can now also be used &lt;a href=&quot;https://github.com/rust-lang/rust/pull/61229&quot;&gt;on &lt;code&gt;enum&lt;/code&gt; definitions&lt;/a&gt;. For example, the following type &lt;code&gt;Align16&lt;/code&gt; would, as expected, report &lt;code&gt;16&lt;/code&gt; as the alignment whereas the natural alignment without &lt;code&gt;#[repr(align(16))]&lt;/code&gt; would be &lt;code&gt;4&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[repr(align(16))]
enum Align16 {
    Foo { foo: u32 },
    Bar { bar: u32 },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The semantics of using &lt;code&gt;#[repr(align(N))&lt;/code&gt; on an &lt;code&gt;enum&lt;/code&gt; is the same as defining a wrapper struct &lt;code&gt;AlignN&amp;lt;T&amp;gt;&lt;/code&gt; with that alignment and then using &lt;code&gt;AlignN&amp;lt;MyEnum&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[repr(align(N))]
struct AlignN&amp;lt;T&amp;gt;(T);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#library-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-changes&quot;&gt;&lt;/a&gt;Library changes&lt;/h3&gt;
&lt;p&gt;In Rust 1.37.0 there have been a number of standard library stabilizations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/io/struct.BufReader.html#method.buffer&quot;&gt;&lt;code&gt;BufReader::buffer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.buffer&quot;&gt;&lt;code&gt;BufWriter::buffer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut&quot;&gt;&lt;code&gt;Cell::from_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_slice_of_cells&quot;&gt;&lt;code&gt;Cell::as_slice_of_cells&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.nth_back&quot;&gt;&lt;code&gt;DoubleEndedIterator::nth_back&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.xor&quot;&gt;&lt;code&gt;Option::xor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.u8.html#method.reverse_bits&quot;&gt;&lt;code&gt;{i,u}{8,16,32,64,128,size}::reverse_bits&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.Wrapping.html#method.reverse_bits&quot;&gt;&lt;code&gt;Wrapping::reverse_bits&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within&quot;&gt;&lt;code&gt;slice::copy_within&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#other-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.37 release: check out what changed in &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15&quot;&gt;Rust&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-137-2019-08-15&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-137&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-137.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-137.0&quot;&gt;&lt;/a&gt;Contributors to 1.37.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.37.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.37.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#new-sponsors-of-rust-infrastructure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-sponsors-of-rust-infrastructure&quot;&gt;&lt;/a&gt;New sponsors of Rust infrastructure&lt;/h2&gt;
&lt;p&gt;We'd like to thank two new sponsors of Rust's infrastructure who provided the resources needed to make Rust 1.37.0 happen: Amazon Web Services (AWS) and Microsoft Azure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS has provided hosting for release artifacts (compilers, libraries, tools, and source code), serving those artifacts to users through CloudFront, preventing regressions with Crater on EC2, and managing other Rust-related infrastructure hosted on AWS.&lt;/li&gt;
&lt;li&gt;Microsoft Azure has sponsored builders for Rust’s CI infrastructure, notably the extremely resource intensive rust-lang/rust repository.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.36.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html" type="text/html" title="Announcing Rust 1.36.0" />
        <published>2019-07-04T00:00:00Z</published>
        <updated>2019-07-04T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.36.0.
Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.36.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website,
and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04&quot;&gt;detailed release notes for 1.36.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.36.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.36.0-stable&quot;&gt;&lt;/a&gt;What's in 1.36.0 stable&lt;/h2&gt;
&lt;p&gt;This release brings many changes, including the stabilization of the &lt;a href=&quot;https://doc.rust-lang.org/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; trait,
the &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; crate, the &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; type, &lt;a href=&quot;http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/&quot;&gt;NLL for Rust 2015&lt;/a&gt;,
a new &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; implementation, and &lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options&quot;&gt;&lt;code&gt;--offline&lt;/code&gt;&lt;/a&gt; support in Cargo.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#the-future-is-here&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-future-is-here&quot;&gt;&lt;/a&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is here!&lt;/h3&gt;
&lt;p&gt;In Rust 1.36.0 the long awaited &lt;a href=&quot;https://doc.rust-lang.org/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; trait has been &lt;a href=&quot;https://github.com/rust-lang/rust/pull/59739&quot;&gt;stabilized&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;With this stabilization, we hope to give important crates, libraries,
and the ecosystem time to prepare for &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;.await&lt;/code&gt;,
which we'll tell you more about in the future.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#the-alloc-crate-is-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-alloc-crate-is-stable&quot;&gt;&lt;/a&gt;The &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; crate is stable&lt;/h3&gt;
&lt;p&gt;Before 1.36.0, the standard library consisted of the crates &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;core&lt;/code&gt;, and &lt;code&gt;proc_macro&lt;/code&gt;.
The &lt;code&gt;core&lt;/code&gt; crate provided core functionality such as &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;Copy&lt;/code&gt;
and could be used in &lt;code&gt;#![no_std]&lt;/code&gt; environments since it did not impose any requirements.
Meanwhile, the &lt;code&gt;std&lt;/code&gt; crate provided types like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and OS functionality
but required a global allocator and other OS capabilities in return.&lt;/p&gt;
&lt;p&gt;Starting with Rust 1.36.0, the parts of &lt;code&gt;std&lt;/code&gt; that depend on a global allocator, e.g. &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;,
are now available in the &lt;code&gt;alloc&lt;/code&gt; crate. The &lt;code&gt;std&lt;/code&gt; crate then re-exports these parts.
While &lt;code&gt;#![no_std]&lt;/code&gt; &lt;em&gt;binaries&lt;/em&gt; using &lt;code&gt;alloc&lt;/code&gt; still require nightly Rust,
&lt;code&gt;#![no_std]&lt;/code&gt; &lt;em&gt;library&lt;/em&gt; crates can use the &lt;code&gt;alloc&lt;/code&gt; crate in stable Rust.
Meanwhile, normal binaries, without &lt;code&gt;#![no_std]&lt;/code&gt;, can depend on such library crates.
We hope this will facilitate the development of a &lt;code&gt;#![no_std]&lt;/code&gt; compatible ecosystem of libraries
prior to stabilizing support for &lt;code&gt;#![no_std]&lt;/code&gt; binaries using &lt;code&gt;alloc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you are the maintainer of a library that only relies on some allocation primitives to function,
consider making your library &lt;code&gt;#[no_std]&lt;/code&gt; compatible by using the following at the top of your &lt;code&gt;lib.rs&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#![no_std]

extern crate alloc;

use alloc::vec::Vec;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#maybeuninitt&gt;-instead-of-mem::uninitialized&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;maybeuninitt&gt;-instead-of-mem::uninitialized&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.uninitialized.html&quot;&gt;&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In previous releases of Rust, the &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.uninitialized.html&quot;&gt;&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/a&gt; function has allowed you to bypass Rust's
initialization checks by pretending that you've initialized a value at type &lt;code&gt;T&lt;/code&gt; without doing anything.
One of the main uses of this function has been to lazily allocate arrays.&lt;/p&gt;
&lt;p&gt;However, &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.uninitialized.html&quot;&gt;&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/a&gt; is an incredibly dangerous operation that essentially
cannot be used correctly as the Rust compiler assumes that values are properly initialized.
For example, calling &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes &lt;em&gt;instantaneous &lt;strong&gt;undefined behavior&lt;/strong&gt;&lt;/em&gt;
as, from Rust's point of view, the uninitialized bits are neither &lt;code&gt;0&lt;/code&gt; (for &lt;code&gt;false&lt;/code&gt;)
nor &lt;code&gt;1&lt;/code&gt; (for &lt;code&gt;true&lt;/code&gt;) - the only two allowed bit patterns for &lt;code&gt;bool&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To remedy this situation, in Rust 1.36.0, the type &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; has been &lt;a href=&quot;https://github.com/rust-lang/rust/pull/60445&quot;&gt;stabilized&lt;/a&gt;.
The Rust compiler will understand that it should not assume that a &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a properly initialized &lt;code&gt;T&lt;/code&gt;.
Therefore, you can do gradual initialization more safely and eventually use &lt;code&gt;.assume_init()&lt;/code&gt;
once you are certain that &lt;code&gt;maybe_t: MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; contains an initialized &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is the safer alternative, starting with Rust 1.39,
the function &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.uninitialized.html&quot;&gt;&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/a&gt; will be deprecated.&lt;/p&gt;
&lt;p&gt;To find out more about uninitialized memory, &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.uninitialized.html&quot;&gt;&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/a&gt;,
and &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, read &lt;a href=&quot;https://gankro.github.io/blah/initialize-me-maybe/&quot;&gt;Alexis Beingessner's blog post&lt;/a&gt;.
The standard library also contains extensive documentation about &lt;a href=&quot;https://doc.rust-lang.org/std/mem/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#nll-for-rust-2015&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;nll-for-rust-2015&quot;&gt;&lt;/a&gt;NLL for Rust 2015&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;In the announcement for Rust 1.31.0&lt;/a&gt;, we told you about NLL (Non-Lexical Lifetimes),
an improvement to the language that makes the borrow checker smarter and more user friendly.
For example, you may now write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;
    let y = &amp;amp;x;
    let z = &amp;amp;mut x; // This was not allowed before 1.31.0.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In 1.31.0 NLL was stabilized only for Rust 2018,
with a promise that we would backport it to Rust 2015 as well.
With Rust 1.36.0, we are happy to announce that we have done so! NLL is now available for Rust 2015.&lt;/p&gt;
&lt;p&gt;With NLL on both editions, we are closer to removing the old borrow checker.
However, the old borrow checker unfortunately accepted some &lt;a href=&quot;https://en.wikipedia.org/wiki/Soundness&quot;&gt;unsound&lt;/a&gt; code it should not have.
As a result, NLL is currently in a &amp;quot;migration mode&amp;quot; wherein we will emit warnings instead
of errors if the NLL borrow checker rejects code the old AST borrow checker would accept.
Please see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60680#issuecomment-495089654&quot;&gt;this list&lt;/a&gt; of public crates that are affected.&lt;/p&gt;
&lt;p&gt;To find out more about NLL, MIR, the story around fixing soundness holes,
and what you can do about the warnings if you have them, read &lt;a href=&quot;http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/&quot;&gt;Felix Klock's blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#a-new-hashmapk,-v&gt;-implementation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;a-new-hashmapk,-v&gt;-implementation&quot;&gt;&lt;/a&gt;A new &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; implementation&lt;/h3&gt;
&lt;p&gt;In Rust 1.36.0, the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; implementation has been &lt;a href=&quot;https://github.com/rust-lang/rust/pull/58623&quot;&gt;replaced&lt;/a&gt;
with the one in the &lt;a href=&quot;https://crates.io/crates/hashbrown&quot;&gt;&lt;code&gt;hashbrown&lt;/code&gt;&lt;/a&gt; crate which is based on the &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; design.
While the interface is the same, the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; implementation is now
&lt;a href=&quot;https://perf.rust-lang.org/compare.html?start=b57fe74a27590289fd657614b8ad1f3eac8a7ad2&amp;end=abade53a649583e40ed07c26ee10652703f09b58&amp;stat=wall-time&quot;&gt;faster on average&lt;/a&gt; and has lower memory overhead.
Note that unlike the &lt;code&gt;hashbrown&lt;/code&gt; crate,
the implementation in &lt;code&gt;std&lt;/code&gt; still defaults to the SipHash 1-3 hashing algorithm.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#--offline-support-in-cargo&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;--offline-support-in-cargo&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options&quot;&gt;&lt;code&gt;--offline&lt;/code&gt;&lt;/a&gt; support in Cargo&lt;/h3&gt;
&lt;p&gt;During most builds, Cargo doesn't interact with the network.
Sometimes, however, Cargo has to.
Such is the case when a dependency is added and the latest compatible version needs to be downloaded.
At times, network access is not an option though, for example on an airplane or in isolated build environments.&lt;/p&gt;
&lt;p&gt;In Rust 1.36, a new Cargo flag has been stabilized: &lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options&quot;&gt;&lt;code&gt;--offline&lt;/code&gt;&lt;/a&gt;.
The flag alters Cargo's dependency resolution algorithm to only use locally cached dependencies.
When the required crates are not available offline, and a network access would be required,
Cargo will exit with an error.
To prepopulate the local cache in preparation for going offline,
use the &lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-fetch.html&quot;&gt;&lt;code&gt;cargo fetch&lt;/code&gt;&lt;/a&gt; command, which downloads all the required dependencies for a project.&lt;/p&gt;
&lt;p&gt;To find out more about &lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options&quot;&gt;&lt;code&gt;--offline&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/cargo/commands/cargo-fetch.html&quot;&gt;&lt;code&gt;cargo fetch&lt;/code&gt;&lt;/a&gt;, read &lt;a href=&quot;https://www.ncameron.org/blog/cargo-offline/&quot;&gt;Nick Cameron's blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For information on other changes to Cargo, see the &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04&quot;&gt;detailed release notes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-changes&quot;&gt;&lt;/a&gt;Library changes&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/macro.dbg.html&quot;&gt;&lt;code&gt;dbg!&lt;/code&gt;&lt;/a&gt; macro now supports multiple arguments.&lt;/p&gt;
&lt;p&gt;Additionally, a number of APIs have been made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.from_size_align_unchecked&quot;&gt;&lt;code&gt;Layout::from_size_align_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.needs_drop.html&quot;&gt;&lt;code&gt;mem::needs_drop&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.cast&quot;&gt;&lt;code&gt;NonNull::cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;New APIs have become stable, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/task/struct.Waker.html&quot;&gt;&lt;code&gt;task::Waker&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/task/enum.Poll.html&quot;&gt;&lt;code&gt;task::Poll&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left&quot;&gt;&lt;code&gt;VecDeque::rotate_left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right&quot;&gt;&lt;code&gt;VecDeque::rotate_right&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored&quot;&gt;&lt;code&gt;Read::read_vectored&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored&quot;&gt;&lt;code&gt;Write::write_vectored&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied&quot;&gt;&lt;code&gt;Iterator::copied&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60404&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;str&amp;gt; for String&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr&quot;&gt;&lt;code&gt;str::as_mut_ptr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other library changes are available in the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04&quot;&gt;detailed release notes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#other-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;Detailed 1.36.0 release notes are available for &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04&quot;&gt;Rust&lt;/a&gt;,
&lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-136.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-136.0&quot;&gt;&lt;/a&gt;Contributors to 1.36.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.36.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.36.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>The Governance WG is going public</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/06/03/governance-wg-announcement.html" type="text/html" title="The Governance WG is going public" />
        <published>2019-06-03T00:00:00Z</published>
        <updated>2019-06-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/06/03/governance-wg-announcement.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/06/03/governance-wg-announcement.html">&lt;p&gt;Hey all! Today we're happy to announce the &lt;a href=&quot;https://internals.rust-lang.org/t/governance-working-group-announcement/9637&quot;&gt;Governance Working Group&lt;/a&gt; is going public. We've been spending the last couple weeks finding our bearings and structuring the working group.&lt;/p&gt;
&lt;p&gt;You can find &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/CHARTER.md&quot;&gt;our charter&lt;/a&gt; outlining our main goals and priorities in &lt;a href=&quot;https://github.com/rust-lang/wg-governance&quot;&gt;our work repository&lt;/a&gt;. We are using the Github issues, milestones and projects to organise and track our progress. The &lt;a href=&quot;https://github.com/rust-lang/wg-governance/&quot;&gt;readme in the repository&lt;/a&gt; explains our working process a bit more in detail. It also states how you can talk to us (hint, via discord) and &lt;a href=&quot;https://github.com/rust-lang/wg-governance/#how-can-i-get-involved&quot;&gt;get involved&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you're interested in the governance working group, you may also be interested in the &lt;a href=&quot;https://internals.rust-lang.org/t/lang-team-meta-working-group/9989&quot;&gt;Lang Team Meta WG&lt;/a&gt;, which is exploring solutions specific to the lang team.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Governance WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.35.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html" type="text/html" title="Announcing Rust 1.35.0" />
        <published>2019-05-23T00:00:00Z</published>
        <updated>2019-05-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.35.0. Rust is a
programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.35.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website,
and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes for 1.35.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.35.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.35.0-stable&quot;&gt;&lt;/a&gt;What's in 1.35.0 stable&lt;/h2&gt;
&lt;p&gt;The highlight of this release is the implementation of the &lt;code&gt;FnOnce&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;,
and &lt;code&gt;Fn&lt;/code&gt; closure traits for &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn FnMut&amp;gt;&lt;/code&gt;, and &lt;code&gt;Box&amp;lt;dyn Fn&amp;gt;&lt;/code&gt; respectively.
Additionally, closures may now be coerced to unsafe function pointers.
The &lt;code&gt;dbg!&lt;/code&gt; macro introduced in &lt;a href=&quot;https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#the-dbg-macro&quot;&gt;Rust 1.32.0&lt;/a&gt; can now also be called without arguments.
Moreover, there were a number of standard library stabilizations.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#fn-closure-traits-implemented-for-box&lt;dyn-fn*&gt;&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;fn-closure-traits-implemented-for-box&lt;dyn-fn*&gt;&quot;&gt;&lt;/a&gt;&lt;code&gt;Fn*&lt;/code&gt; closure traits implemented for &lt;code&gt;Box&amp;lt;dyn Fn*&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In Rust 1.35.0, the &lt;code&gt;FnOnce&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and the &lt;code&gt;Fn&lt;/code&gt; traits &lt;a href=&quot;https://github.com/rust-lang/rust/pull/55431&quot;&gt;are now implemented&lt;/a&gt; for &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt;,
&lt;code&gt;Box&amp;lt;dyn FnMut&amp;gt;&lt;/code&gt;, and &lt;code&gt;Box&amp;lt;dyn Fn&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Previously, if you wanted to call the function stored in a boxed closure, you had to use &lt;a href=&quot;https://doc.rust-lang.org/1.34.0/std/boxed/trait.FnBox.html&quot;&gt;&lt;code&gt;FnBox&lt;/code&gt;&lt;/a&gt;.
This was because instances of &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt; and friends did not implement the respective &lt;code&gt;Fn*&lt;/code&gt; traits.
This also meant that it was not possible to pass boxed functions to code expecting an implementor of a &lt;code&gt;Fn&lt;/code&gt; trait,
and you had to create temporary closures to pass them down.&lt;/p&gt;
&lt;p&gt;This was ultimately due to a limitation in the compiler's ability to reason about such implementations,
which has since been fixed with the introduction of &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/language-features/unsized-locals.html&quot;&gt;unsized locals&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this release, you can now use boxed functions in places that expect items implementing a function trait.&lt;/p&gt;
&lt;p&gt;The following code now works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo(x: Box&amp;lt;dyn Fn(u8) -&amp;gt; u8&amp;gt;) -&amp;gt; Vec&amp;lt;u8&amp;gt; {
    vec![1, 2, 3, 4].into_iter().map(x).collect()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Furthermore, you can now directly call &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt; objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo(x: Box&amp;lt;dyn FnOnce()&amp;gt;) {
    x()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#coercing-closures-to-unsafe-fn-pointers&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;coercing-closures-to-unsafe-fn-pointers&quot;&gt;&lt;/a&gt;Coercing closures to &lt;code&gt;unsafe fn&lt;/code&gt; pointers&lt;/h3&gt;
&lt;p&gt;Since &lt;a href=&quot;https://blog.rust-lang.org/2017/07/20/Rust-1.19.html&quot;&gt;Rust 1.19.0&lt;/a&gt;, it has been possible to coerce closures that do not capture from their environment into function pointers.
For example, you may write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn twice(x: u8, f: fn(u8) -&amp;gt; u8) -&amp;gt; u8 {
    f(f(x))
}

fn main() {
    assert_eq!(42, twice(0, |x| x + 21));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has however not extended to &lt;code&gt;unsafe&lt;/code&gt; function pointers.
With this release of Rust, you may now do so. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// The safety invariants are those of the `unsafe fn` pointer passed.
unsafe fn call_unsafe_fn_ptr(f: unsafe fn()) {
    f()
}

fn main() {
    // SAFETY: There are no invariants.
    // The closure is statically prevented from doing unsafe things.
    unsafe {
        call_unsafe_fn_ptr(|| {
            dbg!();
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#calling-dbg()-with-no-argument&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;calling-dbg()-with-no-argument&quot;&gt;&lt;/a&gt;Calling &lt;code&gt;dbg!()&lt;/code&gt; with no argument&lt;/h3&gt;
&lt;p&gt;For the benefit of all the occasional and frequent &amp;quot;print debuggers&amp;quot; out there,
&lt;a href=&quot;https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#the-dbg-macro&quot;&gt;Rust 1.32.0&lt;/a&gt; saw the release of &lt;a href=&quot;https://doc.rust-lang.org/std/macro.dbg.html&quot;&gt;the &lt;code&gt;dbg!&lt;/code&gt; macro&lt;/a&gt;.
To recap, the macro allows you to quickly inspect the value of some expression with context.
For example, when running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 0;

    if dbg!(x == 1) {
        x += 1;
    }

    dbg!(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...you would see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[src/main.rs:4] x == 1 = false
[src/main.rs:8] x = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As seen in the previous section, where the higher order function &lt;code&gt;call_unsafe_fn_ptr&lt;/code&gt; is called,
you may now also call &lt;code&gt;dbg!&lt;/code&gt; without passing any arguments.
This is useful when tracing what branches your application takes.
For example, with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let condition = true;

    if condition {
        dbg!();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...you would see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[src/main.rs:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;In 1.35.0, a number of APIs have become stable.&lt;/p&gt;
&lt;p&gt;In addition, some implementations were added and other changes occured as well.
See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#copy-the-sign-of-a-floating-point-number-onto-another&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;copy-the-sign-of-a-floating-point-number-onto-another&quot;&gt;&lt;/a&gt;Copy the sign of a floating point number onto another&lt;/h4&gt;
&lt;p&gt;With this release, new methods &lt;code&gt;copysign&lt;/code&gt; have been added to the floating point primitive types &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f32.html#method.copysign&quot;&gt;&lt;code&gt;f32::copysign&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f64.html#method.copysign&quot;&gt;&lt;code&gt;f64::copysign&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the name suggests, you can use these to copy the sign of one number onto another. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    assert_eq!(3.5_f32.copysign(-0.42), -3.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a href=&quot;#check-whether-a-range-contains-a-value&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;check-whether-a-range-contains-a-value&quot;&gt;&lt;/a&gt;Check whether a &lt;code&gt;Range&lt;/code&gt; &lt;code&gt;contains&lt;/code&gt; a value&lt;/h4&gt;
&lt;p&gt;Rust 1.35.0 contains a few freshly minted methods on the &lt;code&gt;Range&lt;/code&gt; types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.Range.html#method.contains&quot;&gt;&lt;code&gt;Range::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeFrom.html#method.contains&quot;&gt;&lt;code&gt;RangeFrom::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeTo.html#method.contains&quot;&gt;&lt;code&gt;RangeTo::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html#method.contains&quot;&gt;&lt;code&gt;RangeInclusive::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html#method.contains&quot;&gt;&lt;code&gt;RangeToInclusive::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these, you can easily check whether a given value exists in a range. For example, you may write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    if (0..=10).contains(&amp;amp;5) {
        println!(&amp;quot;Five is included in zero to ten.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a href=&quot;#map-and-split-a-borrowed-refcell-value-in-two&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;map-and-split-a-borrowed-refcell-value-in-two&quot;&gt;&lt;/a&gt;Map and split a borrowed &lt;code&gt;RefCell&lt;/code&gt; value in two&lt;/h4&gt;
&lt;p&gt;With Rust 1.35.0, you can now map and split the borrowed value of a &lt;code&gt;RefCell&lt;/code&gt; into multiple borrows for different components of the borrowed data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.Ref.html#method.map_split&quot;&gt;&lt;code&gt;Ref::map_split&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.RefMut.html#method.map_split&quot;&gt;&lt;code&gt;RefMut::map_split&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&quot;#replace-the-value-of-a-refcell-through-a-closure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;replace-the-value-of-a-refcell-through-a-closure&quot;&gt;&lt;/a&gt;Replace the value of a &lt;code&gt;RefCell&lt;/code&gt; through a closure&lt;/h4&gt;
&lt;p&gt;This release introduces a convenience method &lt;code&gt;replace_with&lt;/code&gt; on &lt;code&gt;RefCell&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace_with&quot;&gt;&lt;code&gt;RefCell::replace_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With it, you can more ergonomically map and replace the current value of the cell and get back the old value as a result.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#hash-a-pointer-or-reference-by-address-not-value&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;hash-a-pointer-or-reference-by-address-not-value&quot;&gt;&lt;/a&gt;Hash a pointer or reference by address, not value&lt;/h4&gt;
&lt;p&gt;In this release, we have introduced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/fn.hash.html&quot;&gt;&lt;code&gt;ptr::hash&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This function takes a raw pointer and hashes it. Using &lt;code&gt;ptr::hash&lt;/code&gt;,
you can avoid hashing the pointed-to value of a reference and instead hash the address.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#copy-the-contents-of-an-option&amp;t&gt;&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;copy-the-contents-of-an-option&amp;t&gt;&quot;&gt;&lt;/a&gt;Copy the contents of an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;From the very beginning with Rust 1.0.0,
the methods &lt;code&gt;Option::cloned&lt;/code&gt; for &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; have allowed you to clone the contents in case of &lt;code&gt;Some(_)&lt;/code&gt;.
However, cloning can sometimes be an expensive operation and the methods &lt;code&gt;opt.cloned()&lt;/code&gt; provided no hints to that effect.&lt;/p&gt;
&lt;p&gt;With this release of Rust, we introduced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.copied&quot;&gt;&lt;code&gt;Option::copied&lt;/code&gt;&lt;/a&gt; for both &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The functionality of &lt;code&gt;opt.copied()&lt;/code&gt; is the same as for &lt;code&gt;opt.cloned()&lt;/code&gt;.
However, calling the method requires that &lt;code&gt;T: Copy&lt;/code&gt;.
Using this method, you can make sure that code stops compiling should &lt;code&gt;T&lt;/code&gt; no longer implements &lt;code&gt;Copy&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#changes-in-clippy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;changes-in-clippy&quot;&gt;&lt;/a&gt;Changes in Clippy&lt;/h3&gt;
&lt;p&gt;In this release of Rust,
Clippy (a collection of lints to catch common mistakes and improve your Rust code) added a new lint &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds&quot;&gt;&lt;code&gt;drop_bounds&lt;/code&gt;&lt;/a&gt;.
This lint triggers when you add a bound &lt;code&gt;T: Drop&lt;/code&gt; to a generic function. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo&amp;lt;T: Drop&amp;gt;(x: T) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Having a bound &lt;code&gt;T: Drop&lt;/code&gt; is almost always a mistake as it excludes types,
such as &lt;code&gt;u8&lt;/code&gt;, which have trivial drop-glues.
Moreover, &lt;code&gt;T: Drop&lt;/code&gt; does not account for types like &lt;code&gt;String&lt;/code&gt; not having interesting destructor behavior directly but rather as a result of embedding types,
such as &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;, that do.&lt;/p&gt;
&lt;p&gt;In addition to &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds&quot;&gt;&lt;code&gt;drop_bounds&lt;/code&gt;&lt;/a&gt;,
this release of Clippy &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/4101&quot;&gt;split&lt;/a&gt; the lint&lt;code&gt;redundant_closure&lt;/code&gt; into &lt;code&gt;redundant_closure&lt;/code&gt; and &lt;code&gt;redundant_closure_for_method_calls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-135-beta&quot;&gt;detailed release notes for Clippy&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#changes-in-cargo&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;changes-in-cargo&quot;&gt;&lt;/a&gt;Changes in Cargo&lt;/h3&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-135-2019-05-23&quot;&gt;detailed release notes for Cargo&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-135.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-135.0&quot;&gt;&lt;/a&gt;Contributors to 1.35.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.35.0.
We couldn't have done it without all of you.
&lt;a href=&quot;https://thanks.rust-lang.org/rust/1.35.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>The 2019 Rust Event Lineup</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html" type="text/html" title="The 2019 Rust Event Lineup" />
        <published>2019-05-20T00:00:00Z</published>
        <updated>2019-05-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html">&lt;p&gt;We're excited for the 2019 conference season, which we're actually late in writing up. Some
incredible events have already happened! Read on to learn more about all the events occurring
around the world, past and future.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#december-15-16-2018:-rustrush&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;december-15-16-2018:-rustrush&quot;&gt;&lt;/a&gt;December 15-16, 2018: RustRush&lt;/h3&gt;
&lt;p&gt;Yes, &lt;a href=&quot;https://rustrush.ru/&quot;&gt;RustRush&lt;/a&gt; was actually in 2018, but we didn't cover it in the &lt;a href=&quot;https://blog.rust-lang.org/2018/01/31/The-2018-Rust-Event-Lineup.html&quot;&gt;2018 event
lineup&lt;/a&gt; so we're counting it in 2019! This was the first Rust event in Russia.
You can &lt;a href=&quot;https://www.youtube.com/playlist?list=PLTooeo4dmVkQ_1lHJEY99ZTH_oP5ksIUL&quot;&gt;watch the talk videos&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/rustrush1&quot;&gt;follow the conference on Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#march-29-30-2019:-rust-latam&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;march-29-30-2019:-rust-latam&quot;&gt;&lt;/a&gt;March 29-30, 2019: Rust Latam&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust Latam Conference&lt;/a&gt; is Latin America's leading event about Rust. Their first
event happened in Montevideo this year, and &lt;a href=&quot;https://www.youtube.com/playlist?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N&quot;&gt;the videos are available&lt;/a&gt; to watch!
Rust Latam plans to be a yearly event, so &lt;a href=&quot;https://twitter.com/RustLatamConf&quot;&gt;watch Twitter&lt;/a&gt; for information about next
year's event.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#april-20-23-2019:-rustcon-asia&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;april-20-23-2019:-rustcon-asia&quot;&gt;&lt;/a&gt;April 20-23, 2019: RustCon Asia&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rustcon.asia/&quot;&gt;RustCon Asia&lt;/a&gt; was the first Rust conference in Asia! The &lt;a href=&quot;https://www.youtube.com/playlist?list=PL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&quot;&gt;talk videos&lt;/a&gt; are already
available on YouTube! &lt;a href=&quot;https://twitter.com/RustConAsia&quot;&gt;Follow @RustConAsia&lt;/a&gt; on Twitter for future updates.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#april-26-29-2019:-oxidize&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;april-26-29-2019:-oxidize&quot;&gt;&lt;/a&gt;April 26-29, 2019: Oxidize&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://oxidizeconf.com/&quot;&gt;Oxidize&lt;/a&gt; was a conference specifically about using Rust on embedded devices that took
place in Berlin. The videos are now &lt;a href=&quot;https://www.youtube.com/playlist?list=PLXajQV_H-DxJPiJQK8gvou4SUZ8Zfvgm6&quot;&gt;available on YouTube&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/OxidizeConf&quot;&gt;follow @oxidizeconf&lt;/a&gt; on Twitter for future updates.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#june-28-29-2019:-rustlab&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;june-28-29-2019:-rustlab&quot;&gt;&lt;/a&gt;June 28-29, 2019: RustLab&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rustlab.it/&quot;&gt;RustLab&lt;/a&gt; is a new conference for this year that will be taking place in Florence, Italy.
Their session and workshop lineup has been announced, and tickets are now available! &lt;a href=&quot;https://twitter.com/rustlab_conf&quot;&gt;Follow the
conference on Twitter&lt;/a&gt; for the most up-to-date information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#august-22-23-rustconf&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;august-22-23-rustconf&quot;&gt;&lt;/a&gt;August 22-23: RustConf&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rustconf.com/&quot;&gt;The official RustConf&lt;/a&gt; will again be taking place in Portland, OR, USA. Thursday is a
day of trainings and Friday is the main day of talks. See &lt;a href=&quot;https://twitter.com/rustconf&quot;&gt;Twitter&lt;/a&gt; for the latest
announcements!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#september-20-21-colorado-gold-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;september-20-21-colorado-gold-rust&quot;&gt;&lt;/a&gt;September 20-21: Colorado Gold Rust&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cogoldrust.com/&quot;&gt;Colorado Gold Rust&lt;/a&gt; is a new conference for this year, and is taking place in
Denver, CO, USA. Their CFP and ticket sales are open now, and you can also &lt;a href=&quot;https://twitter.com/COGoldRust&quot;&gt;follow them on
twitter&lt;/a&gt;!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#october-18-19-rust-belt-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;october-18-19-rust-belt-rust&quot;&gt;&lt;/a&gt;October 18-19: Rust Belt Rust&lt;/h3&gt;
&lt;p&gt;This year's &lt;a href=&quot;https://www.rust-belt-rust.com/&quot;&gt;Rust Belt Rust&lt;/a&gt; will be taking place in Dayton, OH, USA, the birthplace of
flight! The CFP and ticket sales will open soon. Check &lt;a href=&quot;https://twitter.com/rustbeltrust&quot;&gt;Twitter&lt;/a&gt; for announcements.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#november-rustfest-barcelona&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;november-rustfest-barcelona&quot;&gt;&lt;/a&gt;November: RustFest Barcelona&lt;/h3&gt;
&lt;p&gt;The exact dates for &lt;a href=&quot;https://barcelona.rustfest.eu/&quot;&gt;RustFest Barcelona&lt;/a&gt; haven't been announced yet, but it's
slated to happen sometime in November. Keep an eye on the &lt;a href=&quot;https://twitter.com/rustfest&quot;&gt;RustFest Twitter&lt;/a&gt; for
announcements!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;We are so lucky and excited to have so many wonderful conferences around the world in 2019! Have
fun at the events, and we hope there are even more in 2020!&lt;/p&gt;
</content>

        <author>
            <name>Rust Community Team</name>
        </author>
    </entry>
    
    <entry>
        <title>4 years of Rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html" type="text/html" title="4 years of Rust" />
        <published>2019-05-15T00:00:00Z</published>
        <updated>2019-05-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html">&lt;p&gt;On May 15th, 2015, &lt;a href=&quot;https://blog.rust-lang.org/2015/05/15/Rust-1.0.html&quot;&gt;Rust&lt;/a&gt; was released to the world! After 5 years of open development (and a couple of years of sketching before that), we finally hit the button on making the attempt to create a new systems programming language a serious effort!&lt;/p&gt;
&lt;p&gt;It’s easy to look back on the pre-1.0 times and cherish them for being the wild times of language development and fun research. Features were added and cut, syntax and keywords were tried, and before 1.0, there was a big clean-up that removed a lot of the standard library. For fun, you can check Niko’s blog post on &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2012/04/09/rusts-object-system/&quot;&gt;how Rust's object system works&lt;/a&gt;, Marijn Haverbeke’s talk on &lt;a href=&quot;https://www.youtube.com/watch?v=olbTX95hdbg&quot;&gt;features that never made it close to 1.0&lt;/a&gt; or even the &lt;a href=&quot;http://venge.net/graydon/talks/intro-talk-2.pdf&quot;&gt;introductory slides about Servo&lt;/a&gt;, which present a language looking very different from today.&lt;/p&gt;
&lt;p&gt;Releasing Rust with stability guarantees also meant putting a stop to large visible changes. The face of Rust is still very similar to Rust 1.0. Even with the changes from last year’s 2018 Edition, Rust is still very recognizable as what it was in 2015. That steadiness hides that the time of Rust’s fastest development and growth is &lt;em&gt;now&lt;/em&gt;. With the stability of the language and easy upgrades as a base, a ton of new features have been built. We’ve seen a bunch of achievements in the last year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have been StackOverflow’s &lt;a href=&quot;https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted&quot;&gt;“Most loved programming language”&lt;/a&gt; 4 consecutive years in a row&lt;/li&gt;
&lt;li&gt;We opened up a whole new area of development for stable Rust: &lt;a href=&quot;https://www.rust-lang.org/what/embedded&quot;&gt;embedded development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rust-lang.org/what/wasm&quot;&gt;Rust+WASM&lt;/a&gt; went from an experiment to a usable product, making rustc the first compiler with focus on supporting WASM&lt;/li&gt;
&lt;li&gt;We shipped a new language edition: &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html&quot;&gt;Rust 2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://crates.io&quot;&gt;Crates.io&lt;/a&gt; passed a billion downloads and has over 25,000 crates available&lt;/li&gt;
&lt;li&gt;There’s now over 100 meetups around the world, in 42 countries&lt;/li&gt;
&lt;li&gt;6(!) new conferences were spun up (&lt;a href=&quot;https://rustrush.ru/&quot;&gt;RustRush&lt;/a&gt;, &lt;a href=&quot;https://rustcon.asia/&quot;&gt;RustCon Asia&lt;/a&gt;, &lt;a href=&quot;https://oxidizeconf.com/&quot;&gt;Oxidize&lt;/a&gt;, &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust LATAM&lt;/a&gt;, &lt;a href=&quot;https://cogoldrust.com/&quot;&gt;Colorado Gold Rust&lt;/a&gt;, &lt;a href=&quot;https://www.rustlab.it/&quot;&gt;RustLab Italy&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list could go on and on. While the time before and after release was a time where language changes had huge impact how Rust is perceived, it's becoming more and more important what people start building in and around it. This includes projects like whole game engines, but also many small, helpful libraries, meetup formats, tutorials other educational material. Birthdays are a great time to take a look back over the last year and see the happy parts!&lt;/p&gt;
&lt;p&gt;Rust would be nothing, and especially not winning prizes, without its community. Community happens everywhere! We would like to thank everyone for being along on this ride, from team members to small scale contributors to people just checking the language out and finding interest in it. Your interest and curiosity is what makes the Rust community an enjoyable place to be. Some meetups &lt;a href=&quot;https://calendar.google.com/calendar/embed?showTitle=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;mode=AGENDA&amp;height=400&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com&amp;color=%23691426&amp;ctz=Europe%2FMadrid&quot;&gt;are running birthday parties&lt;/a&gt; today to which everyone is invited. If you are not attending one, you can take the chance to celebrate in any other fashion: maybe show us a picture of what you are currently working on or talk about what excites you. If you want to take it to social media, consider tagging our &lt;a href=&quot;https://twitter.com/rustlang&quot;&gt;Twitter account&lt;/a&gt; or using the hashtag #rustbirthday.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.2</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html" type="text/html" title="Announcing Rust 1.34.2" />
        <published>2019-05-14T00:00:00Z</published>
        <updated>2019-05-14T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.34.2. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.34.2 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.2-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.2-stable&quot;&gt;&lt;/a&gt;What's in 1.34.2 stable&lt;/h2&gt;
&lt;p&gt;Sean McArthur reported a &lt;a href=&quot;https://groups.google.com/d/msg/rustlang-security-announcements/aZabeCMUv70/-2Y6-SL6AQAJ&quot;&gt;security vulnerability&lt;/a&gt; affecting the standard
library that caused the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.downcast&quot;&gt;&lt;code&gt;Error::downcast&lt;/code&gt;&lt;/a&gt; family of methods
to perform unsound casts when a manual implementation of the
&lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.type_id&quot;&gt;&lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt; method returned the wrong
&lt;a href=&quot;https://doc.rust-lang.org/stable/std/any/struct.TypeId.html&quot;&gt;&lt;code&gt;TypeId&lt;/code&gt;&lt;/a&gt;, leading to security issues such as out of bounds
reads/writes/etc.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.type_id&quot;&gt;&lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt; method was recently stabilized as part
of Rust 1.34.0. This point release &lt;strong&gt;destabilizes&lt;/strong&gt; it, preventing any code on
the stable and beta channels to implement or use it, awaiting future plans that
will be discussed in &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60784&quot;&gt;issue #60784&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An in-depth explaination of this issue was posted in yesterday's &lt;a href=&quot;https://groups.google.com/d/msg/rustlang-security-announcements/aZabeCMUv70/-2Y6-SL6AQAJ&quot;&gt;security
advisory&lt;/a&gt;. The assigned CVE for the vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083&quot;&gt;CVE-2019-12083&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the standard library</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/13/Security-advisory.html" type="text/html" title="Security advisory for the standard library" />
        <published>2019-05-13T00:00:00Z</published>
        <updated>2019-05-13T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/13/Security-advisory.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/13/Security-advisory.html">&lt;p&gt;This is a cross-post of the &lt;a href=&quot;https://groups.google.com/forum/#!topic/rustlang-security-announcements/aZabeCMUv70&quot;&gt;official security advisory&lt;/a&gt;. The
official post contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;p&gt;The CVE for this vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083&quot;&gt;CVE-2019-12083&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The Rust team was recently notified of a security vulnerability affecting
manual implementations of &lt;code&gt;Error::type_id&lt;/code&gt; and their interaction with the
&lt;code&gt;Error::downcast&lt;/code&gt; family of functions in the standard library. If your code
does not manually implement &lt;code&gt;Error::type_id&lt;/code&gt; your code is not affected.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#overview&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function in the standard library was stabilized in the
1.34.0 release on 2019-04-11. This function allows acquiring the concrete
&lt;code&gt;TypeId&lt;/code&gt; for the underlying error type to downcast back to the original type.
This function has a default implementation in the standard library, but it can
also be overridden by downstream crates. For example, the following is
currently allowed on Rust 1.34.0 and Rust 1.34.1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct MyType;

impl Error for MyType {
    fn type_id(&amp;amp;self) -&amp;gt; TypeId {
        // Enable safe casting to `String` by accident.
        TypeId::of::&amp;lt;String&amp;gt;()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When combined with the &lt;code&gt;Error::downcast*&lt;/code&gt; family of methods this can enable
safe casting of a type to the wrong type, causing security issues such as out
of bounds reads/writes/etc.&lt;/p&gt;
&lt;p&gt;Prior to the 1.34.0 release this function was not stable and could not be
either implemented or called in stable Rust.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#affected-versions&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function was first stabilized in Rust 1.34.0, released on
2019-04-11. The Rust 1.34.1 release, published 2019-04-25, is also affected.
The &lt;code&gt;Error::type_id&lt;/code&gt; function has been present, unstable, for all releases of
Rust since 1.0.0 meaning code compiled with nightly may have been affected at
any time.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#mitigations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;Immediate mitigation of this bug requires removing manual implementations of
&lt;code&gt;Error::type_id&lt;/code&gt;, instead inheriting the default implementation which is
correct from a safety perspective. It is not the intention to have
&lt;code&gt;Error::type_id&lt;/code&gt; return &lt;code&gt;TypeId&lt;/code&gt; instances for other types.&lt;/p&gt;
&lt;p&gt;For long term mitigation we are going to destabilize this function. This is
unfortunately a breaking change for users calling &lt;code&gt;Error::type_id&lt;/code&gt; and for
users overriding &lt;code&gt;Error::type_id&lt;/code&gt;. For users overriding it's likely memory
unsafe, but users calling &lt;code&gt;Error::type_id&lt;/code&gt; have only been able to do so on
stable for a few weeks since the last 1.34.0 release, so it's thought that the
impact will not be too great to overcome.&lt;/p&gt;
&lt;p&gt;We will be releasing a 1.34.2 point release on 2019-05-14 (tomorrow) which
reverts &lt;a href=&quot;https://github.com/rust-lang/rust/pull/58048&quot;&gt;#58048&lt;/a&gt; and destabilizes the &lt;code&gt;Error::type_id&lt;/code&gt; function. The
upcoming 1.35.0 release along with the beta/nightly channels will also all be
updated with a destabilization.&lt;/p&gt;
&lt;p&gt;The final fate of the &lt;code&gt;Error::type_id&lt;/code&gt; API isn't decided upon just yet and is
the subject of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60784&quot;&gt;#60784&lt;/a&gt;. No action beyond destabilization is currently
planned so nightly code may continue to exhibit this issue. We hope to fully
resolve this in the standard library soon.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#timeline-of-events&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thu, May  9, 2019 at 14:07 PM - Bug reported to security@rust-lang.org&lt;/li&gt;
&lt;li&gt;Thu, May  9, 2019 at 15:10 PM - Alex reponds, confirming the bug&lt;/li&gt;
&lt;li&gt;Fri, May 10, 2019 - Plan for mitigation developed and implemented&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - PRs posted to GitHub for &lt;a href=&quot;https://github.com/rust-lang/rust/pull/60785&quot;&gt;stable&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60786&quot;&gt;beta&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60787&quot;&gt;master&lt;/a&gt; branches&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - Security list informed of this issue&lt;/li&gt;
&lt;li&gt;(planned) Tue, May 14, 2019 - Rust 1.34.2 is released with a fix for this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#acknowledgements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to Sean McArthur, who found this bug and reported it to us in accordance
with our &lt;a href=&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Mozilla IRC Sunset and the Rust Channel</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html" type="text/html" title="Mozilla IRC Sunset and the Rust Channel" />
        <published>2019-04-26T00:00:00Z</published>
        <updated>2019-04-26T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html">&lt;p&gt;The Rust community has had a presence on Mozilla’s IRC network almost since Rust’s inception. Over time, the single channel grew into a set of pretty active channels where folks would come to ask Rust questions, coordinate work on Rust itself, and just in general chat about Rust.&lt;/p&gt;
&lt;p&gt;Mozilla &lt;a href=&quot;http://exple.tive.org/blarg/2019/04/26/synchronous-text/&quot;&gt;recently announced&lt;/a&gt; that it would be shutting down its IRC network, citing a growing maintenance and moderation burden. They are looking into new options for the Mozilla community, but this does leave the question open as to what the Rust project will do.&lt;/p&gt;
&lt;p&gt;Last year a lot of the teams &lt;a href=&quot;https://internals.rust-lang.org/t/exploring-new-communication-channels/7859&quot;&gt;started exploring new communication platforms&lt;/a&gt;. Almost all the Rust teams no longer use IRC as their official discussion platform, instead using Discord or Zulip (as well as a variety of video chat tools for synchronous meetings). The few teams that do use IRC are working with us to find a new home, likely a channel on Discord or Zulip.&lt;/p&gt;
&lt;p&gt;This leaves the #rust and #rust-beginners channels on Mozilla’s IRC network, which are still quite active, that will need a new home when Mozilla’s network shuts down. Rust’s &lt;a href=&quot;http://discord.gg/rust-lang&quot;&gt;official Discord server&lt;/a&gt; does have the #users, #help, and #beginners channels that fill in this purpose, and we recommend people start using those.&lt;/p&gt;
&lt;p&gt;We understand that not everyone wishes to switch to Discord for many reasons. For people who wish to continue using IRC, there is &lt;a href=&quot;http://webchat.freenode.net/?channels=##rust&quot;&gt;an unofficial freenode channel&lt;/a&gt; which you can hang out in, though we’d like to emphasize that this is not associated with the Rust teams and is not moderated by our Moderation team. You’re also free to create new channels on freenode &lt;a href=&quot;https://freenode.net/policies#off-topic-use&quot;&gt;in accordance with the freenode rules&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are still a couple months before irc.mozilla.org shuts down — we’ll work at making this transition as smooth as possible in this time. Thanks to everyone who made #rust and #rust-beginners on Mozilla IRC a great place to hang out! We are sad to see it go. 😢&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html" type="text/html" title="Announcing Rust 1.34.1" />
        <published>2019-04-25T00:00:00Z</published>
        <updated>2019-04-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.1, and a new version of rustup, 1.18.1.
Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup,
getting Rust 1.34.1 and rustup 1.18.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.1-stable&quot;&gt;&lt;/a&gt;What's in 1.34.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes two false positives and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3805&quot;&gt;a panic when checking macros&lt;/a&gt; in &lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;Clippy&lt;/a&gt;.
Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:redundant_closure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:redundant_closure&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::redundant_closure&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;A false positive in the &lt;code&gt;redundant_closure&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3821&quot;&gt;fixed&lt;/a&gt;.
The lint did not take into account &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/issues/3802&quot;&gt;differences in the number of borrows&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the following snippet, the method &lt;code&gt;required&lt;/code&gt; expects &lt;code&gt;dep: &amp;amp;D&lt;/code&gt; but the actual type of &lt;code&gt;dep&lt;/code&gt; is &lt;code&gt;&amp;amp;&amp;amp;D&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;dependencies.iter().filter(|dep| dep.required());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clippy erronously suggested &lt;code&gt;.filter(Dependency::required)&lt;/code&gt;,
which is rejected by the compiler due to the difference in borrows.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:missing_const_for_fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:missing_const_for_fn&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::missing_const_for_fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Another false positive in the &lt;code&gt;missing_const_for_fn&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3844&quot;&gt;fixed&lt;/a&gt;.
This lint did not take into account that functions inside &lt;code&gt;trait&lt;/code&gt; implementations cannot be &lt;code&gt;const fn&lt;/code&gt;s.
For example, when given the following snippet, the lint would trigger:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[derive(PartialEq, Eq)] // warning: this could be a const_fn
struct Point(isize, isize);

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&amp;gt; Self { // warning: this could be a const_fn
        Point(self.0 + other.0, self.1 + other.1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-new-in-rustup-1.18.1&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-new-in-rustup-1.18.1&quot;&gt;&lt;/a&gt;What's new in rustup 1.18.1&lt;/h2&gt;
&lt;p&gt;A recent rustup release, 1.18.0, introduced &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/issues/1794&quot;&gt;a regression&lt;/a&gt; that prevented installing Rust through the shell script on older platforms.
A patch was released that fixes the issue, avoiding to force TLS v1.2 on the platforms that don't support it.&lt;/p&gt;
&lt;p&gt;You can check out other rustup changes in its &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/blob/master/CHANGELOG.md#1181---2019-04-25&quot;&gt;full release notes&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>